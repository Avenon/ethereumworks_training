// Так делать не нужно ))

// Указываем версию для компилятора
pragma solidity ^0.4.11;


// Инициализация контракта
contract MyFirstERC20Coin {
    // Объявляем переменную в которой будет название токена
    string public name;

    // Объявляем переменную в которой будет символ токена
    string public symbol;

    // Объявляем переменную в которой будет число нулей токена
    uint8 public decimals;

    // Добавляем переменную для стоимости одного токена
    uint public buyPrice;


    // Объявляем переменную в которой будет храниться общее число токенов
    uint256 public totalSupply;

    // Объявляем маппинг для хранения балансов пользователей
    mapping (address => uint256) public balanceOf;

    // Объявляем маппинг для хранения одобренных транзакций
    mapping (address => mapping(address => uint256)) public allowance;
    // если этого не сделать, то будет осуществляться перебор на ноде всех значений

    // Объявляем эвент для логгирования события перевода токенов
    event Transfer(address from, address to, uint256 value);
    // Объявляем эвент для логгирования события одобрения перевода токенов
    event Approval(address from, address to, uint256 value);

    // Функция инициализации контракта
    function MyFirstERC20Coin() {
        // Указываем число нулей
        decimals = 8;

        // Объявляем общее число токенов, которое будет создано при инициализации
        // Чтобы получить число копеек после целого
        totalSupply = 1000000 * (10 ** uint256(decimals));

        // Указываем значение стоимости токенов
        // Пусть у нас один токен будет стоить 1000 weiы
        buyPrice = 1000;

        // "Отправляем" все токены на баланс того, кто инициализировал создание контракта токена
        // В нашем случае все токены будут у создателя
        balanceOf[this] = totalSupply;

        // Указываем название токена
        name = "MyFirstERC20Coin";

        // Указываем символ токена
        symbol = "EGR";
    }


    // Внутренняя функция для перевода токенов
    // Нижнее подчеркивание означает то, что данная функция используется только
    // внутри нашего контракта (это сделано для удобства)
    // Модификатор internal делает функцию недоступной из вне
    function _transfer(address _from, address _to, uint256 _value) internal {
        // Переведен введенную сумму в вид, чтобы получить число копеек в токене
        // Так не нужно делать, т.к. функция будет отрабатывать корректно, но
        // при вызове функций send, например из wallet.ethereum.org, число превратится
        // в очень большое, и вернет ошибку (если к примеру будет больше выпуска токенов всего)
        //_value *= (10 ** uint256(decimals));

        // Проверка на пустой адрес
        require(_to != 0x0);

        // Проверка того, что отправителю хватает токенов для перевода
        require(balanceOf[_from] >= _value);

        // Проверка на переполнение
        require(balanceOf[_to] + _value >= balanceOf[_to]);


        // Токены списываются у отправителя
        balanceOf[_from] -= _value;

        // Токены прибавляются получателю
        balanceOf[_to] += _value;

        // Эвент перевода токенов
        Transfer(_from, _to, _value);
    }

    // Функция для перевода токенов
    function transfer(address _to, uint256 _value) public {
        // Вызов внутренней функции перевода
        _transfer(msg.sender, _to, _value);
    }

    // Функция для перевода "одобренных" токенов
    function transferFrom(address _from, address _to, uint256 _value) public {
        // Проверка, что токены были выделены аккаунтом _from для аккаунта _to
        require(_value <= allowance[_from][_to]);

        // Уменьшаем число "одобренных" токенов
        allowance[_from][_to] -= _value;

        // Отправка токенов
        _transfer(_from, _to, _value);
    }

    // Функция для "одобрения" перевода токенов
    function approve(address _to, uint256 _value) public {
        // Записываем в маппинг число "одобренных" токенов
        allowance[msg.sender][_to] = _value;
        // Вызов эвента для логгирования события одобрения перевода токенов
        Approval(msg.sender, _to, _value);
    }

    // Функция для отправки эфиров на контракт
    // Обычная функция без названия
    function () payable {
        // Выполняем внутреннюю функцию контракта
        _buy(msg.sender, msg.value);
    }

    // Функция для отправки эфиров на контракт (вызываемая)
    // Функция для обработки вызова

    // Рекомендуют делать две функции, чтобы потом удобней было взаимодействовать
    // с ней на фронте, при написании Dapp приложений
    function buy() payable {
        // вызова внутренний фунции
        _buy(msg.sender, msg.value);
    }


    // Внутренняя функция покупки
    function _buy(address _from, uint _value) {
        // Получаем количество возможных для покупки токенов по курсу
        uint amount = _value / buyPrice;
        // Вызываем внутреннюю функцию перевода токенов
        _transfer(this, _from, amount);
    }
}
